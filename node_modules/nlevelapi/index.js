/**********************************************************
 * Author : nanyuantingfeng
 * Timestamp : 2015-11-22 05:10
 **********************************************************/
var level = require("level");
var nfix = require("nfix");

var LevelDB = nfix.Class(Object, function(dbPath) {
    this.$db = level(dbPath);
});

LevelDB.fn.$db = undefined;

LevelDB.fn.open = function() {
    return nfix.Promise(this, function(resolve, reject) {
        if(!this.isOpened())
            this.$db.open(function(error) { error ? reject(error) : resolve(); })
    });
};

LevelDB.fn.close = function() {
    return nfix.Promise(this, function(resolve, reject) {
        this.$db.close(function(error) { error ? reject(error) : resolve(); })
    });
};

LevelDB.fn.put = function(key, value, options) {
    return nfix.Promise(this, function(resolve, reject) {
        this.$db.put(key, value, options, function(error) { error ? reject(error) : resolve(key); })
    });
};

LevelDB.fn.get = function(key, options) {
    return nfix.Promise(this, function(resolve, reject) {
        this.$db.get(key, options, function(error, value) { error ? reject(error) : resolve(value); });
    });
};

LevelDB.fn.del = function(key, options) {
    return nfix.Promise(this, function(resolve, reject) {
        this.$db.del(key, options, function(error) { error ? reject(error) : resolve(key); })
    })
};

LevelDB.fn.batch = function(array, options) {
    return nfix.Promise(this, function(resolve, reject) {
        this.$db.batch(array, options, function(error) { error ? reject(error) : resolve(array); })
    })
};

LevelDB.fn.isOpened = function() {
    return this.$db.isOpen();
};

LevelDB.fn.isClosed = function() {
    return this.$db.isClosed();
};

LevelDB.fn.acquire = function(options) {
    return nfix.Promise(this, function(resolve, reject) {
        var data = [];
        options = nfix.merge({}, LevelDB.defaultOptions, options, prefix(options.prefix));
        this.$db.createReadStream(options)
                .on('data', function(d) { data.push(d); })
                .on("end", function() { resolve(data); })
                .on("error", function(error) { reject(error); })
    });
};

LevelDB.fn.iterate = function(options, f) {
    options = nfix.merge({}, LevelDB.defaultOptions, options, prefix(options.prefix));
    this.$db.createReadStream(options).on('data', function(data) {
        f.call(this, data.key, data.value);
    });
};

LevelDB.defaultOptions = {keys : true, values : true, revers : false, fillCache : true};

module.exports = LevelDB.LevelDB = LevelDB;

function prefix(str) {
    return nfix.isString(str) ? {
        gte : str,
        lte : str.slice(0, str.length - 1) + String.fromCharCode(str[str.length - 1].charCodeAt() + 1)
    } : {};
}
